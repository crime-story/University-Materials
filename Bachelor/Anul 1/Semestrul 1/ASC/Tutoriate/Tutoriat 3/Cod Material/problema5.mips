.data
    v:.space 800
    sp:.asciiz " "
    nl:.asciiz "\n"
.text
main:

    li $v0, 5
    syscall
    move $t0, $v0

    li $t1, 0
    li $t2, 0

    read:

        beq $t0, $t1, solve

        li $v0, 5
        syscall
        sw $v0, v($t2)

        addi $t1, $t1, 1
        addi $t2, $t2, 4

        j read

solve:

    la $t1, v                 # încarcă în $t1 adresa de memorie a vectorului
    li $t2, 12                # pune într-un registru valoarea 12
    sw $t2, 4($t1)            # pune pe a doua poziție din vector valoarea 12

    li $t2, 2
    sw $t2, 8($t1)            # pune pe a treia poziție din vector valoarea 2

    li $t1, 0
    li $t2, 0

    loop:

        bge $t1, $t0, exit

        lw $t3, v($t2)

        beq $t3, 99, exit

        beq $t3, 1, adunare   # acum avem 2 cazuri, unul pentru adunare, unul pentru înmulțire
        j cont1               # dacă nu a apărut 1, poate a apărut 2, deci mergem mai jos să verificăm
    
        adunare:               

            move $t4, $t2     # obține cele 3 numere a, b, c ca în programul anterior
            addi $t4, $t4, 4
            lw $t5, v($t4)
            
            addi $t4, $t4, 4
            lw $t6, v($t4)
            
            addi $t4, $t4, 4
            lw $t7, v($t4)
            
            add $t5, $t5, $t5 # înmulțește poziția lui a cu 4 (pentru ca așa "indexăm" noi)
            add $t5, $t5, $t5 # doua adunări repetate înseamnă o înmulțire cu 4

            lw $t5, v($t5)    # obține valoarea din vector de la poziția a

            add $t6, $t6, $t6 # la fel cum am făcut pentru a, facem și pentru b
            add $t6, $t6, $t6

            lw $t6, v($t6)

            add $t5, $t5, $t6 # facem adunarea

            add $t7, $t7, $t7 # la fel, înmulțim poziția cu 4 pentru a putea
            add $t7, $t7, $t7 # accesa în vectorul nostru

            sw $t5, v($t7)    # salvează rezultatul la poziția c

            j cont2           # ne ducem la sfârșitul loop-ului pentru că
                              # știm că nu vom intra pe cazul în care
                              # valoarea este 2
            
        cont1:
        
        beq $t3, 2, inmultire # dacă valoarea citită e 2, este cazul pentru înmulțire

        j cont2               # dacă valoarea nu e nici 1, nici 2, atunci coninuă loop-ul

        inmultire:            # codul pentru v[c] = v[a] * v[b], asemănător cu cel de adunare
                              # majoritatea codului se repetă, probabil s-ar putea face mai elegant
                              # desi atunci succesiunea de branch-uri ar devenit confuzantă
                              # deci, în scop didactic vom avea "copy pasta" aici.

            move $t4, $t2
            addi $t4, $t4, 4
            lw $t5, v($t4)
            
            addi $t4, $t4, 4
            lw $t6, v($t4)
            
            addi $t4, $t4, 4
            lw $t7, v($t4)
            
            add $t5, $t5, $t5
            add $t5, $t5, $t5

            lw $t5, v($t5)

            add $t6, $t6, $t6
            add $t6, $t6, $t6

            lw $t6, v($t6)

            mul $t5, $t5, $t6 # înmulțește cele două numere

            add $t7, $t7, $t7
            add $t7, $t7, $t7

            sw $t5, v($t7)
        
        cont2:

            addi $t1, $t1, 4
            addi $t2, $t2, 16

            j loop
    
exit:

    lw $a0, v                 # ia valoarea de pe prima poziție și o afișează
    li $v0, 1
    syscall

    li $v0, 10
    syscall

